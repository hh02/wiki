created: 20210326083326315
modified: 20210326152304555
tags: 
title: rust learning notes
type: text/vnd.tiddlywiki

cargo build 编译

cargo run 编译&&运行

cargo check 不生成二进制文件

carbo build --release

尽量使用cargo

变量的 shadow (屏蔽）： 新变量可以屏蔽旧变量

变量类型：
1. u32, i32, f32, f64(常用), bool(1byte), char(4byte)
2. isize, usize 由计算机的架构决定

tuple
 
``let tuple = ( , , )``

array ( vector 更灵活)

```rust
let array:[类型，长度] = [, , ]
let a:[3;5]; 注意是分号，  a = [3, 3, 3, 3, 3]
```

rust 不允许数组越界

!!! 语句和表达式

```rust
let y = {
	let x = 3;
	x += 5, // 这儿不能是分号，否则就是一个语句。
}
```

语句不能为变量赋值

函数的返回值：

```rust
fn five() -> i32 {
	5
}
```

5 + 6; 加分号后的返回值是一个空tuple, ()

```rust
if number < 5 { // 必须是 bool 类型
	prinfln!("something");
} else if {
	// something
} else {
	// something
}
```

if 后跟的是表达式：
let condition = true;
let number = if condition {5} else {6};
分支返回类型必须相同

循环

```rust
let result = loop {
	counter += 1;
	if counter == 10 {
		break counter * 2;
	}
};
```

while number != 0 {
}

for 循环最常用

```rust
for element in a.iter() {
	println!("the value is: {}", element);
}
```

Range

```rust
for number in (1..4).rev() {
	//
}
```

!! 4. 所有权

Stack vs Heap

* 引用和借用
  错误示例：

1. mutable he immutalbe 在同一作用域内不能同时出现

```rust
fn main() {
	let mut s1 = String::from("hello");
	let s2 = &mut s1; // s1 is mutable borrowed
	s2.push_str(", world!"); 
	println!("{} {}", s1, s2); // s1 is immutable borrowed
    // 去掉 s2 后不会报错， 因为 mutable borrow s2 未被使用
}
```

2. 多个 mutable 不能在同一作用域内出现:

```rust
fn main() {
    let mut s1 = String::from("hello");
	let s2 = &mut s1; // first mutalbe borrow
	s2.push_str(", world!");
	s1.push_str(", word!"); // second mutalbe borrow
	println!("{}", s2);
}
```

若错误使用 borrow, 只要 borrow 未被使用就不会报错（没有 first borrow later used)。

**总结：在同一个作用域内只能有一个引用对数据进行修改。**

悬垂引用（Dangling References）

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");
    &s
}
```

move:

```rust
let s1 = String::from("hello");
let s2 = s1;
```
s1 移动给了 s2, s1 失效

clone:



拥有copy trait 可以复制

引用和借用
引用默认是不可变的， 
在特定作用域内，对一个变量只能有一个可变引用。

引用的规则总结：

1. 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
2. 引用必须总是有效的。

!!! 4.3 Slices

考虑下面函数：

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

这个函数返回了空格的位置，但这个位置只有在 `&String` 的上下文中才有意义：

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word 的值为 5

    s.clear(); // 这清空了字符串，使其等于 ""

    // word 在此处的值仍然是 5，
    // 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！
}
```

解决方法：字符串 slice

字符串 slice 是 ``String`` 中一部分值的引用：

```rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
let slice = &s[..2];
let slice = &s[3..];
let slice = &s[..];
```

注意：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。

利用字符串 slice 重写 ``first_word``：

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

用 字符串 slice 作为参数：
函数参数中的 ``&String`` 一般用 ``&str`` 代替， 因为这样可以同时传入 ``String`` 和 ``str`` 类型的引用。

下面代码是错误的：

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // s 的不可变引用

    s.clear(); // 错误! s 的可变引用

    println!("the first word is: {}", word);
}
```

在一个作用域中，不能同时出现可变和不可变引用。

 
**字符串的字面值就是 slice**

```rust
let s = "Hello, world!";
```

这里 ``s`` 的类型是 ``&str``：它是一个指向二进制程序特定位置的 slice， 是不可变引用。

!!!! 其他类型的 slice

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
```

!!!! 我的观点

字符串 slice 的类型就是一个 ``str`` 引用， 只是比 ``String`` 引用少了 ``capacity``。


[img width=360 [2021-03-26-rust-4-3-slice01.svg]]
